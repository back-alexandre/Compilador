/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * @aluno1=Alexandre Pereira Back 18100844 
 * @aluno2=Yuri Kayser da Rosa 12201035
 */
options
{
  static = false; //Nao criara metodos estaticos
}

PARSER_BEGIN(Fun)
package parser;

import java.io.*;

public class Fun
{
  boolean Menosshort = false; // saida resumida -= false
  public static void main(String args []) throws ParseException
  {
   
    String filename = "";
    Fun divertido;
    int i;
    boolean ms = false;

    for (i = 0; i< args.length - 1; i++)
    {
      if (args[i].toLowerCase().equals("-short"))
        ms = true;
      else
      {
        System.out.println("Usage is: java Fun [-short] inputfile");
        System.exit(0);

      }

    }

    if (args[i].equals("-"))
    {
      System.out.println("Reading from stantard input...");
      divertido = new Fun(System.in);
    }
    else
    { // le do arquivo
      filename = args[args.length-1];
      System.out.println("Lendo do arquivo...");
      try {
        divertido = new Fun(new java.io.FileInputStream(filename));
      }
      catch (java.io.FileNotFoundException e) {
		System.out.println("File " + filename + " not found.");
      	return;
      }  
    }
    divertido.Menosshort = ms;
    divertido.program(); // metodo que faz analise

    // verifica se houve erro léxico
    if (divertido.token_source.foundLexError() != 0 )
      System.out.println(divertido.token_source.foundLexError() +  "Erros léxicos encontrads");
    else
      System.out.println("Programa analisado com sucesso");
    // 
  }
  static public String im(int x) // metodo auxiliar
  {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {s = s.substring(1,k); }
      catch(StringIndexOutOfBoundsException e) {}
    return s;
  }
}

PARSER_END(Fun)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

SKIP:
{
 "/*": multilinecomment
}

<multilinecomment > SKIP:
{
  "*/" : DEFAULT
|  <~[]> 
}

SKIP:
{
 "//": singlelinecomment
}

<singlelinecomment > SKIP:
{
  <["\n","\r"] > : DEFAULT
|  <~[]> 
}

SPECIAL_TOKEN: /* tratar os erros léxicos */
{
<INVALID_LEXICAL:
( ~ ["a"-"z", "A"-"Z",
  "0"-"9",
  "\"",
  "\'",
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  ";",
  ",",
  ".",
  "=",
  ">",
  "<",
  "!",
  "+",
  "-",
  "*",
  "/",
  "%",
  " ",
  "\t",
  "\n",
  "\r",
  "\f" 
])+>
  {
    System.err.println("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);
    countLexError++;
  }
|
<INVALIND_CONST:
 "\"" (~ ["\n", "\r", "\""])* ["\n","\r"] >
  {
    System.err.println("Line " + input_stream.getEndLine() +  " - String constant has a \\n: " + image);
    countLexError++;
  }
|
<INVALIND_CHAR:
 "\'" (~ ["\r", "\""]) >
  {
    System.err.println("Line " + input_stream.getEndLine() +  " - Char constant has a \\r: " + image);
    countLexError++;
  }
}


TOKEN_MGR_DECLS :
{
int countLexError = 0;

public int  foundLexError()
{
  return countLexError;
}

}

TOKEN : /* Palavras reservadas */
{
  < BREAK : "break" >
| < CLASS : "class" >
| < CONSTRUCTOR : "constructor" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FOR : "for" >
| < IF : "if" >
| < INT : "int" >
| < FLOAT : "float" >
| < NEW : "new" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < STRING : "string" >
| < CHAR : "char" >
| < SUPER : "super" >
| < BOOLEAN : "boolean" >
}

TOKEN : /* OPERATORS */
{ < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NEQ : "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < REM : "%" >
| < NOT : "not" >
| < AND : "and" >
| < OR : "or" >
| < XOR : "xor" >
}

TOKEN : /* Simbolos Especiais */
{ < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

TOKEN : /* constantes */
{
  < int_constant:( // nrs decimais inteiros, octais, hexa ou binarios
                   (["0"-"9"] (["0"-"9"])* ) |
                   (["0"-"7"] (["0"-"7"])* ["o", "O"] ) |
                   (["0"-"9"] (["0"-"7","A"-"F","a"-"f"])*  ["h", "H"] ) |
                   (["0"-"1"] (["0"-"1"])* ["b", "B"]) 
                  ) >
|
< float_constant:( // 
                   ((["0"-"9"])+ ["."] (["0"-"9"])+ ) 
                  ) >
|
 <  char_constant: // constante char
   "\'"( ~["\'","\r"]) "\'" >
|    
 <  string_constant: // constante string
   "\""( ~["\"","\n","\r"])* "\"" >
|
 < null_constant: "null" > // constante null
|
 < boolean_constant:( "true" | "false" )> // constantes boleanas

}

TOKEN : /* Identificadores */
{
 <  IDENT: <LETTER> (<LETTER>|<DIGIT>)* >
|
 < #LETTER: ["A"-"Z","a"-"z"] >
|
 < #DIGIT: ["0"-"9"] >

}

void program() :
{}
{
  (
    <int_constant> { System.out.println("Reconheceu int_constant"); } 
  | <float_constant> { System.out.println("Reconheceu float_constant"); } 
  | <char_constant> { System.out.println("Reconheceu char_constant"); } 
  | <string_constant> { System.out.println("Reconheceu string_constant"); } 
  | <null_constant> { System.out.println("Reconheceu null_constant"); } 
  | <boolean_constant> { System.out.println("Reconheceu boolean_constant"); }  
  | <IDENT> { System.out.println("Reconheceu IDENT"); }  
  | <NOT> { System.out.println("Reconheceu NOT"); }  
  | <AND> { System.out.println("Reconheceu AND"); }  
  | <OR> { System.out.println("Reconheceu OR"); }  
  | <XOR> { System.out.println("Reconheceu XOR"); }  
  )*
}
